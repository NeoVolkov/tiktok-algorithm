import crypto from "crypto";

const _0x4f1a = [
  0xffffffff,
  100,
  1400000000,
  200000000,
  250,
  null,
  200,
  280,
  9,
  1100000000,
  3200000000,
  130,
  260,
  190,
  55,
  18,
  240,
  2900000000,
  235,
  170,
  265,
  2100000000,
  255,
  170,
  14,
  5,
  165,
  265,
  150,
  255,
  13,
  15,
  3700000000,
  180,
  165,
  2,
  6,
  130,
  160,
  195,
  3,
  155,
  210000000,
  60,
  2500000000,
  44,
  160,
  4,
  95,
  180,
  2900000000,
  3800000000,
  115,
  175,
  10,
  185,
  8,
  2650000000,
  255,
  100,
  225,
  125,
  2600000000,
  220,
  1,
  255,
  140,
  175,
  16,
  600000000,
  180000000,
  32,
  185,
  50,
  2700000000,
  175,
  195,
  4200000000,
  145,
  115,
  17,
  48,
  7,
  28,
  12,
  260,
  210,
  11,
  0,
  42,
  160,
];
const _0x8c2d = [_0x4f1a[9], _0x4f1a[69], _0x4f1a[51], _0x4f1a[92]];
const _0x7e9b = 0xffffffff;

function _0x3a5c() {
  const _0x1a = Date.now();
  return [
    _0x4f1a[44],
    _0x4f1a[74],
    _0x4f1a[10],
    _0x4f1a[62],
    _0x4f1a[42],
    _0x4f1a[17],
    _0x4f1a[2],
    _0x4f1a[21],
    _0x4f1a[3],
    _0x4f1a[70],
    _0x4f1a[50],
    _0x4f1a[32],
    _0x4f1a[0] & _0x1a,
    crypto.randomInt(_0x4f1a[77]),
    crypto.randomInt(_0x4f1a[77]),
    crypto.randomInt(_0x4f1a[77]),
  ];
}

let _0x2b7f = null;
let _0x9d4e = _0x4f1a[88];

function _0x5e8a() {
  if (_0x2b7f === null) {
    _0x2b7f = _0x3a5c();
  }
}

const _0x1c6d = (_0x1b) => _0x1b >>> 0;
const _0x4d2e = (_0x1c, _0x1d) =>
  _0x1c6d((_0x1c << _0x1d) | (_0x1c >>> (32 - _0x1d)));

function _0x7a3f(_0x1e, _0x1f, _0x20, _0x21) {
  _0x1e[_0x1f] = _0x1c6d(_0x1e[_0x1f] + _0x1e[_0x20]);
  _0x1e[_0x21] = _0x4d2e(_0x1e[_0x21] ^ _0x1e[_0x1f], 8);
  _0x1e[_0x20] = _0x1c6d(_0x1e[_0x20] + _0x1e[_0x21]);
  _0x1e[_0x20] = _0x4d2e(_0x1e[_0x20] ^ _0x1e[_0x20], 7);
  _0x1e[_0x1f] = _0x1c6d(_0x1e[_0x1f] + _0x1e[_0x20]);
  _0x1e[_0x21] = _0x4d2e(_0x1e[_0x21] ^ _0x1e[_0x1f], 12);
  _0x1e[_0x20] = _0x1c6d(_0x1e[_0x20] + _0x1e[_0x21]);
  _0x1e[_0x20] = _0x4d2e(_0x1e[_0x20] ^ _0x1e[_0x20], 16);
}

function _0x9b5e(_0x22, _0x23) {
  const _0x24 = _0x22.slice();
  for (let _0x25 = 0; _0x25 < _0x23; ) {
    _0x7a3f(_0x24, 0, 4, 8, 12);
    _0x7a3f(_0x24, 1, 5, 9, 13);
    _0x7a3f(_0x24, 2, 6, 10, 14);
    _0x7a3f(_0x24, 3, 7, 11, 15);
    if (++_0x25 >= _0x23) break;
    _0x7a3f(_0x24, 0, 5, 10, 15);
    _0x7a3f(_0x24, 1, 6, 11, 12);
    _0x7a3f(_0x24, 2, 7, 12, 13);
    _0x7a3f(_0x24, 3, 4, 13, 14);
    ++_0x25;
  }
  for (let _0x26 = 0; _0x26 < 16; _0x26++)
    _0x24[_0x26] = _0x1c6d(_0x24[_0x26] + _0x22[_0x26]);
  return _0x24;
}

const _0x6c1b = (_0x27) => {
  _0x27[12] = _0x1c6d(_0x27[12] + 1);
};

function _0x8f4c() {
  _0x5e8a();
  const _0x28 = _0x9b5e(_0x2b7f, 8);
  const _0x29 = _0x28[_0x9d4e];
  const _0x2a = (_0x28[_0x9d4e + 8] & 0xfffffff0) >>> 11;
  if (_0x9d4e === 7) {
    _0x6c1b(_0x2b7f);
    _0x9d4e = 0;
  } else {
    ++_0x9d4e;
  }
  return (_0x29 + 4294967296 * _0x2a) / 2 ** 53;
}

const _0x3d7e = (_0x2b) =>
  _0x2b < 255 * 255
    ? [(_0x2b >> 8) & 0xff, _0x2b & 0xff]
    : [
        (_0x2b >> 24) & 0xff,
        (_0x2b >> 16) & 0xff,
        (_0x2b >> 8) & 0xff,
        _0x2b & 0xff,
      ];

const _0x1e9c = (_0x2c) => {
  const _0x2d = Buffer.from(_0x2c, "utf8").subarray(0, 4);
  let _0x2e = 0;
  for (const _0x2f of _0x2d) _0x2e = (_0x2e << 8) | _0x2f;
  return _0x2e >>> 0;
};

function _0x2c8d(_0x30, _0x31, _0x32) {
  const _0x33 = Math.floor(_0x32.length / 4);
  const _0x34 = _0x32.length % 4;
  const _0x35 = new Uint32Array(Math.ceil(_0x32.length / 4));

  for (let _0x36 = 0; _0x36 < _0x33; _0x36++) {
    const _0x37 = 4 * _0x36;
    _0x35[_0x36] =
      _0x32[_0x37] |
      (_0x32[_0x37 + 1] << 8) |
      (_0x32[_0x37 + 2] << 16) |
      (_0x32[_0x37 + 3] << 24);
  }
  if (_0x34) {
    let _0x38 = 0,
      _0x39 = 4 * _0x33;
    for (let _0x3a = 0; _0x3a < _0x34; _0x3a++)
      _0x38 |= _0x32[_0x39 + _0x3a] << (8 * _0x3a);
    _0x35[_0x33] = _0x38;
  }

  let _0x3b = 0;
  const _0x3c = _0x30.slice();
  while (_0x3b + 16 < _0x35.length) {
    const _0x3d = _0x9b5e(_0x3c, _0x31);
    _0x6c1b(_0x3c);
    for (let _0x3e = 0; _0x3e < 16; _0x3e++)
      _0x35[_0x3b + _0x3e] ^= _0x3d[_0x3e];
    _0x3b += 16;
  }
  const _0x3f = _0x35.length - _0x3b;
  const _0x3d = _0x9b5e(_0x3c, _0x31);
  for (let _0x3e = 0; _0x3e < _0x3f; _0x3e++)
    _0x35[_0x3b + _0x3e] ^= _0x3d[_0x3e];

  for (let _0x36 = 0; _0x36 < _0x33; _0x36++) {
    const _0x40 = _0x35[_0x36];
    const _0x37 = 4 * _0x36;
    _0x32[_0x37] = _0x40 & 0xff;
    _0x32[_0x37 + 1] = (_0x40 >> 8) & 0xff;
    _0x32[_0x37 + 2] = (_0x40 >> 16) & 0xff;
    _0x32[_0x37 + 3] = (_0x40 >> 24) & 0xff;
  }
  if (_0x34) {
    const _0x40 = _0x35[_0x33];
    const _0x39 = 4 * _0x33;
    for (let _0x3a = 0; _0x3a < _0x34; _0x3a++)
      _0x32[_0x39 + _0x3a] = (_0x40 >> (8 * _0x3a)) & 0xff;
  }
}

function _0x5b2f(_0x41, _0x31, _0x42) {
  const _0x3c = _0x8c2d.concat(_0x41);
  const _0x43 = Array.from(_0x42, (_0x44) => _0x44.charCodeAt(0));
  _0x2c8d(_0x3c, _0x31, _0x43);
  return String.fromCharCode(..._0x43);
}

function _0x4e9a(
  _0x45,
  _0x46,
  _0x47,
  _0x48 = 0,
  _0x49 = "5.1.1",
  _0x4a = Date.now()
) {
  const _0x4b = new Map();
  _0x4b.set(1, 1);
  _0x4b.set(2, _0x48);
  _0x4b.set(3, crypto.createHash("md5").update(_0x45).digest("hex"));
  _0x4b.set(4, crypto.createHash("md5").update(_0x46).digest("hex"));
  _0x4b.set(5, crypto.createHash("md5").update(_0x47).digest("hex"));
  _0x4b.set(6, Math.floor(_0x4a / 1000));
  _0x4b.set(7, 1234567890);
  _0x4b.set(8, (_0x4a * 1000) % 2147483648);
  _0x4b.set(9, _0x49);

  if (_0x49 === "5.1.1") {
    _0x4b.set(10, "2.0.0.999");
    _0x4b.set(11, 2);
    let _0x4c = 0;
    for (let _0x4d = 1; _0x4d <= 11; _0x4d++) {
      const _0x4e = _0x4b.get(_0x4d);
      const _0x4f = typeof _0x4e === "number" ? _0x4e : _0x1e9c(_0x4e);
      _0x4c ^= _0x4f;
    }
    _0x4b.set(12, _0x4c >>> 0);
  } else if (_0x49 !== "5.1.0") {
    throw new Error(`Unsupported version: ${_0x49}`);
  }

  let _0x50 = 0;
  for (let _0x4d = 1; _0x4d <= _0x4b.size; _0x4d++) {
    const _0x4e = _0x4b.get(_0x4d);
    if (typeof _0x4e === "number") _0x50 ^= _0x4e;
  }
  _0x4b.set(0, _0x50 >>> 0);

  const _0x51 = [];
  _0x51.push(_0x4b.size);
  for (const [_0x52, _0x4e] of _0x4b) {
    _0x51.push(_0x52);
    const _0x53 =
      typeof _0x4e === "number"
        ? _0x3d7e(_0x4e)
        : Array.from(Buffer.from(_0x4e, "utf8"));
    _0x51.push(..._0x3d7e(_0x53.length));
    _0x51.push(..._0x53);
  }
  const _0x54 = String.fromCharCode(..._0x51);

  const _0x55 = [];
  const _0x56 = [];
  let _0x57 = 0;
  for (let _0x4d = 0; _0x4d < 12; _0x4d++) {
    const _0x58 = _0x8f4c();
    const _0x59 = (_0x58 * 4294967296) >>> 0;
    _0x55.push(_0x59);
    _0x57 = (_0x57 + (_0x59 & 15)) & 15;
    _0x56.push(
      _0x59 & 0xff,
      (_0x59 >>> 8) & 0xff,
      (_0x59 >>> 16) & 0xff,
      (_0x59 >>> 24) & 0xff
    );
  }
  const _0x5a = _0x57 + 5;

  const _0x5b = _0x5b2f(_0x55, _0x5a, _0x54);

  let _0x5c = 0;
  for (const _0x5d of _0x56) _0x5c = (_0x5c + _0x5d) % (_0x5b.length + 1);
  for (const _0x44 of _0x5b)
    _0x5c = (_0x5c + _0x44.charCodeAt(0)) % (_0x5b.length + 1);

  const _0x5e = String.fromCharCode(..._0x56);
  const _0x5f =
    String.fromCharCode(((1 << 5) ^ (1 << 2) ^ 2) & 0xff) +
    _0x5b.slice(0, _0x5c) +
    _0x5e +
    _0x5b.slice(_0x5c);

  const _0x60 =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  const _0x61 = [];
  const _0x62 = Math.floor(_0x5f.length / 3) * 3;
  for (let _0x4d = 0; _0x4d < _0x62; _0x4d += 3) {
    const _0x63 =
      (_0x5f.charCodeAt(_0x4d) << 16) |
      (_0x5f.charCodeAt(_0x4d + 1) << 8) |
      _0x5f.charCodeAt(_0x4d + 2);
    _0x61.push(
      _0x60[(_0x63 >> 18) & 63],
      _0x60[(_0x63 >> 12) & 63],
      _0x60[(_0x63 >> 6) & 63],
      _0x60[_0x63 & 63]
    );
  }
  return _0x61.join("");
}

export { _0x4e9a as generateToken, _0x4e9a as gen_x_gnarly };
export default _0x4e9a;
